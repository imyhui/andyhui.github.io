<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Go 指南练习]]></title>
    <url>%2F2019%2F03%2F12%2Fgo-tour%2F</url>
    <content type="text"><![CDATA[Go 指南 Go语言官方给出了一份教程，基本涵盖了涵盖了该语言的大部分重要特性 形式是知识点 + 代码的形式，很喜欢这样的学习方式 这篇博客记录下每道练习题的自己的解答及官方解答。 练习：循环与函数 作为练习函数和循环的简单途径，用牛顿法实现开方函数。 在这个例子中，牛顿法是通过选择一个初始点 z 然后重复这一过程求 Sqrt(x) 的近似值： $z=z-\frac{z^{2}-x}{2z}$为了做到这个，只需要重复计算 10 次，并且观察不同的值（1，2，3，……）是如何逐步逼近结果的。 然后，修改循环条件，使得当值停止改变（或改变非常小）的时候退出循环。观察迭代次数是否变化 提示：定义并初始化一个浮点值，向其提供一个浮点语法或使用转换： 12z := float64(1)z := 1.0 my solution1234567891011121314151617181920package mainimport ( "fmt" "math")func Sqrt(x float64) float64 &#123; z := float64(x/2) for s := 1; s &lt;= 1&lt;&lt;20; s++ &#123; z -= (z*z - x) / 2 * z &#125; return z&#125;func main() &#123; n := 2 fmt.Println(Sqrt(float64(n))) fmt.Println(math.Sqrt(float64(n)))&#125; go Team solutionloops.go 1234567891011121314151617181920212223package mainimport ( "fmt" "math")const delta = 1e-6func Sqrt(x float64) float64 &#123; z := x n := 0.0 for math.Abs(n-z) &gt; delta &#123; n, z = z, z-(z*z-x)/(2*z) &#125; return z&#125;func main() &#123; const x = 2 mine, theirs := Sqrt(x), math.Sqrt(x) fmt.Println(mine, theirs, mine-theirs)&#125; 练习：slice 实现 Pic。它返回一个 slice 的长度 dy，和 slice 中每个元素的长度的 8 位无符号整数 dx。当执行这个程序，它会将整数转换为灰度（好吧，蓝度）图片进行展示。 图片的实现已经完成。可能用到的函数包括 (x+y)/2、 x*y 和 x^y（使用 math.Pow计算最后的函数）。 （需要使用循环来分配 [][]uint8 中的每个 []uint8。） （使用 uint8(intValue) 在类型之间进行转换。） my solution12345678910111213141516171819202122232425262728293031323334353637package mainimport ( "golang.org/x/tour/pic" "math")func cal(x, y, n int) uint8 &#123; var res uint8 switch n &#123; case 1: res = uint8((x + y) / 2) case 2: res = uint8(x * y) case 3: res = uint8(x ^ y) case 4: res = uint8(x * int(math.Log(float64(y)))) case 5: res = uint8(x % (y + 1)) &#125; return res&#125;func Pic(dx, dy int) [][]uint8 &#123; res := make([][]uint8, dy) for y := range res &#123; res[y] = make([]uint8, dx) for x := range res[y] &#123; res[y][x] = cal(x,y,5) &#125; &#125; return res&#125;func main() &#123; pic.Show(Pic)&#125; 运行结果 go Team solutionslices.go 12345678910111213141516171819202122package mainimport "golang.org/x/tour/pic"func Pic(dx, dy int) [][]uint8 &#123; p := make([][]uint8, dy) for i := range p &#123; p[i] = make([]uint8, dx) &#125; for y, row := range p &#123; for x := range row &#123; row[x] = uint8(x * y) &#125; &#125; return p&#125;func main() &#123; pic.Show(Pic)&#125; 练习：map 实现 WordCount。它应当返回一个含有 s中每个 “词” 个数的 map。函数 wc.Test针对这个函数执行一个测试用例，并输出成功还是失败。 你会发现 strings.Fields 很有帮助。 my solution == go Team solutionmaps.go 123456789101112131415161718package mainimport ( "strings" "golang.org/x/tour/wc")func WordCount(s string) map[string]int &#123; count := make(map[string]int) for _, word := range strings.Fields(s) &#123; count[word]++ &#125; return count&#125;func main() &#123; wc.Test(WordCount)&#125; 练习：斐波纳契闭包 现在来通过函数做些有趣的事情。 实现一个fibonacci 函数，返回一个函数（一个闭包）可以返回连续的斐波纳契数列 (0, 1, 1, 2, 3, 5, ...)。 my solution123456789101112131415161718192021package mainimport "fmt"// fibonacci is a function that returns// a function that returns an int.func fibonacci() func(int) int &#123; dp := []int&#123;0, 1&#125; for i := 2; i &lt; 100; i++ &#123; dp = append(dp, dp[i-1] + dp[i-2]) &#125; return func(x int) int &#123; return dp[x] &#125;&#125;func main() &#123; f := fibonacci() for i := 0; i &lt; 10; i++ &#123; fmt.Println(f(i)) &#125;&#125; go Team solutionfib.go 1234567891011121314151617181920package mainimport "fmt"// fibonacci is a function that returns// a function that returns an int.func fibonacci() func() int &#123; f, g := 1, 0 return func() int &#123; f, g = g, f+g return f &#125;&#125;func main() &#123; f := fibonacci() for i := 0; i &lt; 10; i++ &#123; fmt.Println(f()) &#125;&#125; To be continue…]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer 12矩阵中的路径]]></title>
    <url>%2F2019%2F03%2F11%2F%E5%89%91%E6%8C%87Offer-12%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[矩阵中的路径题目描述 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 思路 首先应将字符串转为二维数组，然后对于每个字母作为起始字母DFS扫描一遍即可，注意搜索的写法。 代码1234567891011121314151617181920212223242526272829303132333435# -*- coding:utf-8 -*-class Solution: def hasPath(self, matrix, rows, cols, path): # write code here if rows == 0 or cols == 0: return False self.build_matrix(matrix, rows, cols) for i in range(rows): for j in range(cols): if self.find(i, j, 0, rows, cols, path): return True return False def find(self, i, j, l, rows, cols, path): if l == len(path): return True if i &lt; 0 or i &gt;= rows or j &lt; 0 or j &gt;= cols or self.flag[i][j] or self.new_matrix[i][j] != path[l]: return False self.flag[i][j] = 1 for n in [[-1, 0], [1, 0], [0, -1], [0, 1]]: if self.find(i+n[0], j+n[1], l+1, rows, cols, path): return True self.flag[i][j] = 0 return False def build_matrix(self, matrix, rows, cols): self.flag = [] self.new_matrix = [] for i in range(rows): self.flag.append([0]*cols) self.new_matrix.append(list(matrix[i*cols:cols+i*cols]))# s = Solution()# print(s.hasPath("ABCESFCSADEE", 3, 4, "ABCCED"))]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer 7重建二叉树]]></title>
    <url>%2F2019%2F03%2F10%2F%E5%89%91%E6%8C%87Offer-7%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[重建二叉树题目描述 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 思路 前序遍历取出根节点，可根据此将中序遍历结果分为左右子树两部分，递归实现此过程即可 代码12345678910111213141516# -*- coding:utf-8 -*-class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Noneclass Solution: # 返回构造的TreeNode根节点 def reConstructBinaryTree(self, pre, tin): if not pre or not tin: return None root = TreeNode(pre.pop(0)) index = tin.index(root.val) root.left = self.reConstructBinaryTree(pre, tin[:index]) root.right = self.reConstructBinaryTree(pre, tin[index + 1:]) return root 拓展LeetCode 1008. 先序遍历构造二叉搜索树 返回与给定先序遍历 preorder 相匹配的二叉搜索树（binary search tree）的根结点。 (回想一下，二叉搜索树是二叉树的一种，其每个节点都满足以下规则，对于 node.left 的任何后代，值总 &lt; node.val，而 node.right 的任何后代，值总 &gt; node.val。此外，先序遍历首先显示节点的值，然后遍历 node.left，接着遍历 node.right。） 12输入：[8,5,1,7,10,12]输出：[8,5,10,1,7,null,12] 代码1234567891011class Solution: def bstFromPreorder(self, preorder) -&gt; TreeNode: if not preorder: return None root = TreeNode(preorder[0]) itr = 1 while itr &lt; len(preorder) and preorder[itr] &lt; preorder[0]: itr += 1 root.left = self.bstFromPreorder(preorder[1: itr]) root.right = self.bstFromPreorder(preorder[itr:]) return root]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer15 二进制中1的个数]]></title>
    <url>%2F2019%2F03%2F09%2F%E5%89%91%E6%8C%87Offer15-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[二进制中1的个数题目描述 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 思路1 32位整数取出每一位，与1做&amp;，求和即可 代码112345678class Solution: def NumberOf1(self, n): # move n count = 0 for _ in range(32): count += n &amp; 1 n = n &gt;&gt; 1 return count 思路2 对比思路一，不对n做移位，而是用一个变量，实现一个过滤器的作用来取每一位 代码2123456789def NumberOf1(self, n): # move flag count = 0 flag = 1 for _ in range(32): if n &amp; flag: count += 1 flag &lt;&lt;=1 return count 思路3 对于一个数n, n&amp;(n-1)结果即消掉末尾1的结果，如8 = (1100)_{2}，8-1 = 7 = (1011)_{2} 1100 &amp; 1011 = 1000 即消去了末尾的1 注意 由于Python 的动态类型，导致数字不会像C++那样溢出int范围变为0，因此要先做一步处理，若为负数则加上 2*32次方，转为补码，再进行统计 代码3123456789def NumberOf12(self, n): # not run if n&lt;0 if n&lt;0: n += 2**32 count = 0 while n != 0: count += 1 n = n &amp; (n-1) return count]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer03 数组中重复的数字]]></title>
    <url>%2F2019%2F03%2F07%2F%E5%89%91%E6%8C%87Offer03-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[数组中重复的数字题目描述 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 思路 排序后两两比较需要O(nlogn)时间，哈希表存储可以O(1) 查找，整体时间复杂度O(n) ，同时空间复杂度也为O(n)，若允许修改原数组，可以用原数组数的值和下标的对应关系来解，扫描到下标为i的数字m，若该m与i不同，则找数组中m位置对应的数字，若该数字与m相同，则重复，若不同则交换两数字位置，这种解法时间复杂度O(n)，空间复杂度O(1)。 代码1234567891011121314151617181920212223242526# -*- coding:utf-8 -*-class Solution: # 这里要特别注意~找到任意重复的一个值并赋值到duplication[0] # 函数返回True/False def duplicate(self, numbers, duplication): # 允许修改数组 不允许额外空间 n = len(numbers) if n == 0: return False for i in range(n): if numbers[i] &lt; 0 or numbers[i] &gt; n - 1: return False for i in range(n): if numbers[i] != i: if numbers[numbers[i]] == numbers[i]: duplication[0] = numbers[i] return True tmp = numbers[numbers[i]] numbers[numbers[i]] = numbers[i] numbers[i] = tmp return Falses = Solution()x = [0]print(s.duplicate([2,3,1,0,2,5,3],x))print(x) 数组中重复数字2题目描述 在一个长度为n+1的数组里的所有数字都在1~n的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为8的数组{2, 3, 5, 4, 3, 2, 6, 7}，那么对应的输出是重复的数字2或者3。 思路 不修改数组，可以开一个大小为n的数组，与上题思路一致，若不适用额外空间，可采取二分统计数字，若一个s到e的范围内数字超过e-s + 1，则该范围内可能有重复的数字，采取二分查找即可。n个数字count_range被调用O(log(n))次，每次需O(n)时间，所以时间复杂度为O(nlogn)，空间复杂度为O(1) 注意 本题数组限制为长度为n+1的数组里的所有数字都在1~n的范围内，若没有这个条件可能解答会不成立 代码1234567891011121314151617181920212223242526272829303132 # -*- coding:utf-8 -*-class Solution: # 函数返回True/False def duplicate(self, numbers, duplication): # 不允许修改数组 n = len(numbers) if n == 0: return -1 start, end = 1, n - 1 while start &lt;= end: mid = start + ((end-start)&gt;&gt;1) print(start,mid,end) count = self.count_range(numbers, start, mid) if start == end: if count &gt; 1: return start else: break if count &gt; mid - start + 1: end = mid else: start = mid + 1 return -1 def count_range(self, numbers, start, end): if len(numbers) == 0: return 0 count = 0 for i in numbers: if i &gt;= start and i &lt;= end: count += 1 return count]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 练习册，每天一个小程序]]></title>
    <url>%2F2019%2F03%2F06%2FPython-%E7%BB%83%E4%B9%A0%E5%86%8C%EF%BC%8C%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AA%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[Talk is cheap. Show me the code.—Linus Torvalds 最近发现一个有趣的项目——show-me-the-code，25道python, 题目，涵盖各个方面，同时兼具挑战性，考察编码能力和资料搜集学习能力。 写在前面完整代码在这里更新，为了不污染全局Python环境，使用了pipenv管理依赖，要运行代码只需只需 123pipenv installpipenv shellpython xxx.py 0000 将你的 QQ 头像（或者微博头像）右上角加上红色的数字，类似于微信未读信息数量那种提示效果。 查资料得知，Python3图像处理库为Pillow，于是看到了廖雪峰老师的教程，简单看了下几个例子及Pillow文档，代码便很容易写了 1234567891011121314151617from PIL import Image, ImageDraw, ImageFontdef main(): # 打开图片，获取图片宽度和高度 im = Image.open('avatar.jpg') w, h = im.size # 创建Draw对象 draw = ImageDraw.Draw(im) # 导入字体创建Font对象 font = ImageFont.truetype('Arial.ttf', 36) # 图片左上角为(0, 0), 绘制文本为'99+', 字体为导入的字体，填充颜色为红色 draw.text((w*0.90, h*0.01),'99+', font=font,fill='#FF0000') im.show()if __name__ == "__main__": main() 运行效果 未完待续。。。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 两数之和系列]]></title>
    <url>%2F2019%2F03%2F05%2FLeetCode%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[[1] 两数之和描述 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 思路 对于本题，给出的数组是未排序的，若两两求和需要O(n^{2}), 如果排序后再双指针遍历，则需要O(nlogn + n), 考虑到HashMap，可以O(1) 查找，因此对于一个数字nums[i],如果target-nums[i]出现过，则输出对应位置，若不存在则记录该数字与位置。 代码123456789101112131415161718class Solution(object): def twoSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ if len(nums) &lt; 2: return [-1, -1] map = &#123;&#125; for i in range(len(nums)): if target - nums[i] in map: return [i, map[target - nums[i]]] else: map[nums[i]] = is = Solution()print(s.twoSum([2, 7, 11, 15],9)) [167] 两数之和 II - 输入有序数组描述 给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明: 返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例: 输入: numbers = [2, 7, 11, 15], target = 9 输出: [1,2] 解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 思路 双指针i,j，i指向较小元素，j指向较大元素， 令 sum = numbers[i]+numbers[j] 若sum &lt; target, i+= 1, 使 sum 变大 若sum &gt; target, j -= 1，使 sum 变小 代码123456789101112131415161718192021class Solution(object): def twoSum(self, numbers, target): """ :type numbers: List[int] :type target: int :rtype: List[int] """ i = 0 j = len(numbers) - 1 while i &lt; j: sum = numbers[i] + numbers[j] if sum == target: return [i+1, j+1] elif sum &lt; target: i += 1 else: j -= 1 return [-1, -1] s = Solution()print(s.twoSum([2, 7, 11, 15], 9)) [653] 两数之和 IV - 输入 BST描述 给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。 示例: 案例 1:12345678输入: ⁠ 5⁠ / \⁠ 3 6⁠/ \ \2 4 7Target = 9 12输出:True 案例 2:12345678输入: ⁠ 5⁠ / \⁠ 3 6⁠/ \ \2 4 7Target = 28 12输出:False 思路 找到两数字存在即可 思路1 前序遍历一遍，用HashSet记录访问过节点的值，对于每个值val查target-val是否存在即可，时间空间复杂度均为O(n)​ 思路2 BFS遍历, 对树来说即层序遍历，同样用HashSet记录访问过的节点，与思路1不同的地方仅是树的遍历方式，时空复杂度均为O(n) 思路3 给定的树为二叉搜索树，inorder遍历结果即为升序排列的列表，这样就转向了两数之和 II双指针即可完成查找，中序遍历加后面的查找，时空复杂度均为O(n)​ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172# Definition for a binary tree node.class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None# 思路1class Solution(object): def findTarget(self, root, k): """ :type root: TreeNode :type k: int :rtype: bool """ dic = &#123;&#125; return self.pre_order(root, dic, k) def pre_order(self, root, dic, k): if root == None: return False if k - root.val in dic: return True dic[root.val] = 1 return self.pre_order(root.left, dic, k) or self.pre_order(root.right, dic, k) # 思路2 def findTarget2(self, root, k): if not root: return False nodes, dic = [root], set() for node in nodes: if k - node.val in dic: return True dic.add(node.val) if node.left: nodes.append(node.left) if node.right: nodes.append(node.right) return False# 思路3 def findTarget(self, root, k): """ :type root: TreeNode :type k: int :rtype: bool """ nums = self.inorder(root) l,r = 0,len(nums) - 1 while l &lt; r: sum = nums[l] + nums[r] if sum == k: return True elif sum &lt; k: l += 1 else: r -= 1 return False def inorder(self, root): if root == None: return [] return self.inorder(root.left) + [root.val] + self.inorder(root.right) root = TreeNode(5)rl = TreeNode(3)rr = TreeNode(6)root.left = rlroot.right = rrrl.left = TreeNode(2)rl.right = TreeNode(4)rr.right = TreeNode(7)s = Solution()print(s.findTarget(root,9)) 拓展 剑指Offer34 二叉树中和为某一值的路径]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CI 持续集成]]></title>
    <url>%2F2019%2F03%2F04%2FContinuous_Integration%2F</url>
    <content type="text"><![CDATA[之前废弃Hexo时，觉得hexo比较麻烦，每次都要执行123hexo cleanhexo deployhexo generate ，才能推到线上，虽然有人把命令简化了一下1hexo clean &amp;&amp; hexo d -g 一行就能搞定，但我还是觉得命令太长，每次复制太麻烦，于是发现了持续集成工具travis-ci，因此顺便了解一下持续集成。 什么是持续集成？ 持续集成（英语：Continuous integration，缩写 CI）是一种软件工程流程，是将所有软件工程师对于软件的工作副本持续集成到共享主线（mainline）的一种举措。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。 也就是说，上面的命令可以通过持续集成工具自动化执行，这样每次我们对博客做出的修改，只需提交commit后，推送到github，持续集成工具自动在线构建博客并部署到GitHub Pages,简化了博客发布流程。 下面是几张图片描述下持续集成、持续交付和持续部署 持续集成 持续集成强调开发人员提交了新代码之后，立刻进行构建、（单元）测试。根据测试结果，我们可以确定新代码和原有代码能否正确地集成在一起。 持续交付 持续交付在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境的「类生产环境」（production-like environments）中。比如，我们完成单元测试后，可以把代码部署到连接数据库的 Staging 环境中更多的测试。如果代码没有问题，可以继续手动部署到生产环境中。 持续部署 持续部署则是在持续交付的基础上，把部署到生产环境的过程自动化。 关于Hexo的一次持续集成实践 详细流程见这里 写下对于这个的一些补充 对于博客源文件，最好添加.gitignore,忽略掉node_modules，依赖文件太大，影响上传速度。 仓库必须Public,私有仓库既不能通过name.github.io访问，也不能完成CI 对于主题文件，如果有.git文件可能会造成git add失败，如果主题不打算更新可删掉主题文件内的.git文件夹 下一步计划 学习主流CI工具，如Jenkins 基于Docker的CI平台实践 参考文档EasyHexo 持续集成Continuous Integration 致产品经理： 持续集成、持续交付、持续部署和DevOps 如何理解持续集成、持续交付、持续部署？ 推荐阅读微服务化的基石——持续集成]]></content>
      <categories>
        <category>devops</category>
      </categories>
      <tags>
        <tag>CI</tag>
        <tag>devops</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新的开始]]></title>
    <url>%2F2019%2F03%2F04%2F1stoftterm%2F</url>
    <content type="text"><![CDATA[2019年3月4日，大三下新学期开始的第一天 又重新把远古的hexo博客重新在黑苹果上，记得上次折腾博客还是在大一下的那个暑假，那时还在搞算法，正值暑期培训，开学就面临着学习算法还是开发的抉择。 人生的好多选择都在不经意间，一方面觉得自己高中没参加过算法竞赛，可能基础落后一些，另一方面经过几次集训联赛，已经彻底对算法失去了信心，学习算法的确有些枯燥，整日面向输入输出编程，屏幕里只有黑框框，也正是这样，走上了web开发这条道路。(有时候会对自己做过的选择有些后悔，但转念一想，是之前的所有选择造就了现在的我，在特定时间点上，对于那个时候的我来说，选项可能本来就只有一个）。 两次多校联赛后，连签到题都不想看了，那时对于web开发的理解，仅止于开发网站，不知道前后端是干啥的，稀里糊涂的就开始了后端开发这条路（虽然最初的一些工作并不是后端的），看别人的教程，说先从搭建一个博客开始，于是我开始了对hexo的折腾。那时候经常翻别人的博客，看到有意思的便查实现，然后照搬到自己的博客上，最终的作品在那时看来还是有模有样的(现在看来我确实不适合做前端）。 大二上开学后，留部答辩，拿着我的hexo博客已经几个入门级的爬虫参加了面试，那时的我还沾沾自喜，觉得自己学到了不少东西，面试结束后，敲响了一记警钟，时刻要保持虔诚，不要因为看到了这个行业的一点就自以为窥一斑而见全豹，犹记得我告诉下一届学弟学妹，搭建博客不在搭建美化的过程，而在于你的记录，勤于写博客才是搭建博客的真正意义，然而，我自己都没有做到…… 现在，已经是大三下学期了，上届的学长们在这个时候，早已经出去实习了，自己相较于那时的他们，还是太菜了，固守于旧知识，没有任何计划，盲目的去学习，可能是那段时间最真实的写照，不要看到什么都想要去了解一下，仅仅是为了增加谈资的学习，真的是不值得。找准目标，有目的有计划的学习，是今后努力的方向。 寒假对面试做了一部分准备，相较于持续不断的学习，考前突击这样的填鸭式灌输一点效果都没有，经过一次面试，也对整个流程有了更深入的了解，同时，也对自己的水平有了正确的认识，面试，不能抱着答上来就万事大吉了，面试是对自己的知识水平的考察，准备面试的过程，也是知识积累的过程，固然面试难度不同以往，但只要自身实力过硬，是不会愁没有伯乐的。 寒假时，看到别人拿到offer，已经走入实习岗位，多少还是有些焦虑的，觉得自己落后了好多，甚至一度觉得自己不适合开发，不如去考研逃避一下，后来渐渐释然了，不一定要刻意的去走别人的道路，那只是正确道路的一条，并不一定适合自己，自己做出的选择，要对自己负责，人生没有SL，能做的只是谨慎对待每次选择。 重新启用这个博客，博客的样式也不在那么华丽，换了一个简约的风格，可能这样更适合自己，洗尽铅华，归于平淡，谨以此博客记录接下来的学习历程。]]></content>
      <categories>
        <category>个人</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[15分钟用Docker部署PHP开发环境]]></title>
    <url>%2F2017%2F12%2F09%2FLaradockInstall%2F</url>
    <content type="text"><![CDATA[为什么使用laradock 搭建环境对于上手框架的新人是一件头疼的事,多人协作开发,线上线下环境的一致也是一个很麻烦的问题,而laradock的使用,完美解决了这个问题,相比homestead与vagrant,laradock更加轻量级,只需要数秒就可以完成启动,既可以作为开发环境也可以作为生产环境,支持PHP、MySQL、 Nginx等一系列软件,且安装较为简便。 支持的软件有12345678&gt; Database Engines: MySQL - MariaDB - Percona - MongoDB - Neo4j - RethinkDB - MSSQL - PostgreSQL - Postgres-PostGIS.&gt; Database Management: PhpMyAdmin - Adminer - PgAdmin&gt; Cache Engines: Redis - Memcached - Aerospike&gt; PHP Servers: NGINX - Apache2 - Caddy&gt; PHP Compilers: PHP FPM - HHVM&gt; Message Queueing: Beanstalkd - RabbitMQ - PHP Worker&gt; Queueing Management: Beanstalkd Console - RabbitMQ Console&gt; Random Tools: HAProxy - Certbot - Blackfire - Selenium - Jenkins - ElasticSearch - Kibana - Grafana - Mailhog - MailDev - Minio - Varnish - Swoole - Laravel Echo… 依赖 Git Docker &gt;= 1.12 可以通过docker -v查看自己的docker版本，一定要保证大于1.12，否则会遇到各种问题，推荐安装17.0以上，之前1.13.1mysql启动不了。 附上我的docker版本 1234567891011121314151617&gt; docker versionClient:Version: 17.05.0-ceAPI version: 1.29Go version: go1.7.5Git commit: 89658beBuilt: Thu May 4 22:09:06 2017OS/Arch: linux/amd64Server:Version: 17.05.0-ceAPI version: 1.29 (minimum version 1.12)Go version: go1.7.5Git commit: 89658beBuilt: Thu May 4 22:09:06 2017OS/Arch: linux/amd64Experimental: false 安装选择安装位置 首先选择一个文件目录，克隆laradock，理论上文件目录可以任选，推荐这样的文件结构 123+ laradock+ project-1+ project-2 这样每个项目文件夹和laradock是平行的关系，多个项目共用一个laradock,也可以每个项目单独装一个laradock，推荐第一种方式 安装laradock1git clone https://github.com/laradock/laradock.git 安装Laravel 进入laradock文件夹 1cd ~/Code/laradock Code是我存放项目的文件夹 修改配置文件 1cp env-example .env 编辑.env文件可以修改需要安装软件，以及相关软件的设置，如php版本、mysql数据库名称等 构建环境 1docker-compose up -d nginx mysql workspace 和 php-fpm会自动启动，这个不用添加在后面，后面可选择的软件有 1nginx, hhvm, php-fpm, mysql, redis, postgres, mariadb, neo4j, mongo, apache2, caddy, memcached, beanstalkd, beanstalkd-console, workspace 第一次构建需下载安装镜像，会花较长时间，之后启动仅需数秒。 可以用docker-compose ps查看容器运行状态 进入workspace容器 执行Artisan, Composer, PHPUnit等命令需要进入workspace容器内才能执行 1docker-compose exec --user=laradock workspace bash 以laradock身份进入容器，也可以执行docker-compose exec workspace bash Laravel相关配置 从一个项目的创建来说明相关配置 创建一个Laravel项目 1composer create-project laravel/laravel testapp --prefer-dist &quot;5.5.*&quot; 修改刚创建应用的.env文件，主要要修改以下几个地方 12345678...DB_HOST=mysqlDB_DATABASE=defaultDB_USERNAME=defaultDB_PASSWORD=secretREDIS_HOST=redis... 修改nginx相关配置 进入nginx站点配置文件夹/laradock/nginx/sites 默认给出了app.conf.example, laravel.conf.example 等文件夹，克隆一份修改对应名字 1cp app.conf.example testapp.conf 编辑配置文件 修改下主页对应位置，/var/www/对应的是laradock的同级目录，应用要对应到public文件夹 1234...server_name testapp.dev;root /var/www/testapp/public;... 在hosts里添加解析,文件路径为/etc/hosts 1127.0.0.1 testapp.dev 重启nginx 12&gt; docker-compose restart nginxRestarting laradock_nginx_1 ... done 打开浏览器输入testapp.dev看到如下界面即安装成功 参考官方文档项目地址]]></content>
      <categories>
        <category>后端学习</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>laradock</tag>
        <tag>docker</tag>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后端学习路径]]></title>
    <url>%2F2017%2F11%2F04%2Flearnpath%2F</url>
    <content type="text"><![CDATA[大一刷了一年算法 到省赛结束也算是圆满退役了，从暑假开始零零散散的学习web开发，到现到现在大二上过半了依旧很迷茫，还好接下来的时间不太忙碌，足够去弥补。前段时间在思考写博客的意义是什么，一方面，作为一个博客，是要记录自己的学习历程，另一方面，是留给后来者，能给别人以启迪，算是实现了写博客的意义吧。之前写的几篇，都是偏向教程向，写起来很累，基本是从0开始考虑的，后续我觉得还是以记录为主，但教程还是要继续写的，现在网络这么普及，网上教程五花八门，中间会有各种坑,而且连贯性很差，我希望留下点东西能给后来者。接下是学长给的后端开发学习路线，顺便就拿过来了，接下来我会在学长的基础上完善这个教程，留作俱乐部的学习资料。 入门篇了解html是什么，以及网页运作的原理 学习使用现代化的开发工具！——换一个好看又好用的文本编辑器吧 前端认知：使用css和js为网页增添色彩 后端认知：使用表单和服务端交互吧！——认识HTTP和PHP以及会话 编程认知：面向对象和函数式编程 linux入门，告别windows 数据库认知：mysql入门 web应用认知：搭建wordpress 工程篇学习使用库：使用bootstrap快速写出好看的页面 学习代码管理：使用git实现代码同步，注册自己的github库，尝试使用多分支进行协作开发 学习包管理：使用composer，以现代的方式构建应用并获取扩展吧 集成开发环境入门：给自己换个IDE吧! 学习设计模式：用MVC的架构去编写应用 使用框架吧：从最简单的框架(CodeIgniter)开始，了解如何使用框架开发应用 应用篇（这一章将会带大家从零构建一个完整的简易博客系统 ，了解一个项目的基本开发流程） 需求分析 原型设计 数据层设计 逻辑架构设计 编写后端代码 编写前端代码 上线部署和调试 高级话题：运维，web安全 进阶篇前后端分离前端的学习路径和技术栈后端的学习路径和技术栈一些简单的设计模式和架构如何进一步学习 作者：MarkyLumin原帖地址]]></content>
      <categories>
        <category>后端学习</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git及GitHub使用]]></title>
    <url>%2F2017%2F09%2F20%2Fgitfirstuse%2F</url>
    <content type="text"><![CDATA[Git什么是 Git Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency. 项目加上Git后能能更好的追踪代码修改，进行版本回溯等操作。当今时代，多人协作开发是公司合作的基本模式，在多人协作的开发过程中Git变得必不可少，接下来大致介绍下Git的基本命令以及GitHub的基本使用。 为什么用Git提高开发效率! git不仅仅是一个代码版本管理工具，也是一个文档管理工具，在git上很容易维护一个文档 git可以提高开发效率，主要表现在: 合并对提交过程的保留 修正提交 廉价好用的本地分支 更强大智能的合并能力 完整配套的开发过程设施(wiki issue 功能大赞！) 查看日志 转自 Koudle Git的下载及安装首先肯定是下载Git( 提醒:资源下载较慢，推荐挂vpn) 然后安装界面如下(windows平台) 这里注意这两个都是添加到右键菜单栏，很好用 一路next下去就好 安装完后 打开终端输入注意 $ 是表示从命令行输入，不用自己输入，只需要输入后面内容即可，后面一致1$ git --version 如果显示1git version 2.14.1.windows.1 表示安装成功了 Git基本设置在桌面上右键Git Bash here 启动git bush命令行界面当然也可以从终端打开 首先我们对 Git 进行全局用户名和邮箱进行设置，请参照下面格式，Your Name 替换为你的名字， you@example.com 替换为你的邮箱这里个人信息设置的作用，是为你在代码提交时自动署名标记，方便查看提交日志时区分作者。12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email you@example.com 接下来进行Git推送分支相关设置这个是命令 Git当我们执行 git push 没有指定分支时，自动使用当前分支，而不是报错。更多关于push.default 1$ git config --global push.default simple Git基本操作对于有经验的开发者来说，在他每次新建完开发项目的时候，首先要做的第一件事就是将自己的项目纳入到 Git 代码版本管理中，完成这个操作一般需要以下这几个步骤： 对Git进行初始化我们要在对应的项目文件夹(文件夹内)对git初始化，windows下可直接在对应文件夹下右键 Git Bush here也可以用命令行找到对应文件夹，这里我们用命令行示范下12$ cd D:/andyhui/DataStructure$ git init D:/andyhui/DataStructure这个是我自己的文件目录，替换成你项目的文件目录即可,如果没有就自己创建一个，在里面随意放一个文件即可，比如 一个说明what.md或 代码文件 HelloWorld.cpp 将项目所有文件纳入到Git暂存区中这些文件并未真正提交到Git上这里-A 是all的意思，我们也可以指定一个文件1$ git add -A 这里的所有文件指的是没在 .gitignore 中被忽略的文件。在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会来选择忽略掉一些我们不想纳入到 Git 版本管理中的文件（如缓存文件）。git忽略文件设置以及了解更多.gitignore。 检查 Git 状态这条命令将会向你输出存放在 Git 暂存区的文件，这意味着这些文件还未真正提交到 Git 中。1$ git status 保留改动并提交这行命令会将暂存区的文件都提交到 Git，-m 选项后面带的参数表示本次提交的简单描述。1234567$ git commit -m &quot;Initial commit&quot;$ git logcommit e7419d269d65021fa056b731e09f8bdeaac00d9d (HEAD -&gt; master, origin/master)Author: andyhui &lt;andyhui686666@gmail.com&gt;Date: Thu Sep 21 09:24:53 2017 +0800 Initial commit 查看历史提交记录：1$ git log 从输出信息中可以很清晰的看到每次提交的作者、日期、描述等信息。按 q可退出查看。 git 基本提交操作到这就结束了，如果你想学习更多关于 Git 相关的知识，可以查阅《Pro Git》一书进行学习。 GitHub什么是 GitHubGitHub 是目前全球最大的代码托管平台，许多非常著名的项目如 Linux、Swift、Laravel 等都托管在 GitHub 上。开发者们利用 GitHub 来进行团队协作开发，查阅或收藏别人开源项目的优秀代码，针对某个 Bug 进行技术讨论等。 GitHub基本操作注册 GitHub 账号如果你还没有 GitHub 账号的话，请先 注册。 为 GitHub 账号设置 SSH Key生成 SSH Key，开始之前，我们先使用以下命令来检查主机上是否已经生成过 SSH Key：1$ ls -al ~/.ssh 如果存在 id_rsa 和 id_rsa.pub的话，请跳过以下生成 SSH 的步骤继续阅读剩下内容。否则使用以下方法来生成 SSH Key，请将 your_email@example.com 替换为你的邮箱：1$ ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot; 命令行会提示让你指定秘钥的名称，按回车键将 SSH Key保存到默认文件名即可：1Enter a file in which to save the key (/Users/you/.ssh/id_rsa): [Press enter] 接下来会询问你为 SSH Key 设置密码，每次提交需要用到，可以设置，也可以按回车键即可，默认为空密码：12Enter passphrase (empty for no passphrase): [Type a passphrase]Enter same passphrase again: [Type passphrase again] 可以都选择默认，也就是直接敲击几个 Enter 键即可。这时候我们再检查一下：1$ ls -al ~/.ssh 可以看到以下两个文件：12id_rsa —— SSH 秘钥的 私钥 (Private Key)id_rsa.pub —— SSH 秘钥的 公钥 (Public Key) 接下来将 SSH Key 添加到 ssh-agent 中：12$ eval `ssh-agent -s`$ ssh-add ~/.ssh/id_rsa 打印出公钥 id_rsa.pub 文件里的内容，并把输出的内容复制到剪贴板里：1$ cat ~/.ssh/id_rsa.pub 最后我们需要将公钥添加到 GitHub 账号，先打开 Github SSH 令牌管理页面，然后把你刚刚复制的令牌按照下图示例添加： 测试ssh key是否成功1$ ssh -T git@github.com 输入完密码后，如果出现You’ve successfully authenticated, but GitHub does not provide shell access 。这就表示已成功连上github。 提交代码到 Github在配置完 GitHub 账号之后，我们便可以开始在上面存放项目代码了。首先 新建一个 GitHub 仓库，取名为 你项目的名字，填上 Description 项目描述，Initialize this repository with a README 这一项是询问你是否需要生成一个默认的介绍。 创建完成之后，使用以下命令将代码上传到 GitHub 上（将 your_username 替换为你自己的 GitHub 用户名，your_projectname 是你的项目名字，就是刚刚创建仓库的名字）：12$ git remote add origin git@github.com:your_username/your_projectname.git$ git push -u origin master 至此，项目已成功托管到 GitHub 上。(如果Git 提示fatal: remote origin already exists请看这里)(如果提示error: src refspec master does not match any请看这里)) 小总结后面我们如果对本地代码进行了改动，只需运行这 3 条命令即可将代码推送到安全可靠的 GitHub 上： 注意：以下命令作为知识重温，不需要执行 1、保存到暂存区,-A也可以换成指定文件：1$ git add -A 2、输入描述信息并提交到本地的 Git：1$ git commit -m &quot;Say something&quot; 3、将代码推送到 GitHub：1$ git push Git 进阶操作误删恢复通过上面 Git 的基本讲解，你可能还无法真正体会到 Git 的强大。在平时开发中，我们有时候可能会因为手误或其它原因将某些重要文件删除。如果之前有将此文件纳入到 Git 中，这时便可以利用 Git 来对误删文件进行恢复。请看下面演示。 我们先假装不小心删除 what.md 文件：12$ rm what.md$ ll 使用 ll 打印出文件目录列表时，能看到 what.md 文件已被成功移除。 查看 Git 状态： 1234567891011$ git statusOn branch masterYour branch is up-to-date with &apos;origin/master&apos;.Changes not staged for commit: (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) deleted: what.mdno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 能看到有相关提示显示 what.md 文件已被删除，这时你可以选择将删除的文件进行恢复或提交。 下面我们使用 Git 进行恢复被删除文件：12$ git checkout -f$ ll 这时能看到 what.md 文件已成功恢复。git checkout -f 的作用是将在暂存区的更改文件进行强制撤销。 从GitHub克隆项目到本地首先到我们要克隆的到GitHub的某个仓库，比如neuq-acmclubTD,右边有个绿色的Clone or download，点开后有Clone with HTTPS，当然你也可以直接下载 然后回到要存放的目录下，右键Git Bash here使用命令1$ git clone https://github.com/imyhui/neuq-acmclubTD.git 如果本地的版本不是最新的，可以使用以下命令，origin是本地仓库1$ git fetch origin 把更新的内容合并到本地分支，可以使用以下命令1$ git merge origin/master 如果你不想手动去合并，那么你可以使用以下命令,这个命令可以拉去最新版本并自动合并1git pull &lt;本地仓库&gt; master 注意:记得如果不是单独另需创建的branch，每次对本地仓库操作的时候都要使用 git pull命令，更新远程仓库到本地中，防止冲突。这点和SVN的update类似 GitHub的分支管理几乎所有的版本控制系统都以某种形式支持分支。使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。 有人把 Git 的分支模型称为它的‘必杀技特性’，也正因为这一特性，使得 Git从众多版本控制系统中脱颖而出。了解分支 分支创建合并删除 首先选中主分支git checkout master 代表将当前分支切换到 master 分支上，master 分支是我们初始化 Git 时默认创建的主分支，其它分支都是基于主分支衍生出来的。 1$ git checkout master 创建一个本地分支： git branch &lt;新分支名字&gt;,比如 1$ git branch new_branch 切换到新建立的分支： git checkout &lt;新分支名&gt; 12$ git checkout new_branchSwitched to branch &apos;new_branch&apos; 2、3 步骤其实可以用一条命令搞定 git checkout -b new_branch，我习惯用这条,区别参考这里 你可以将新建的 new_branch 理解为是对 master 分支的克隆，在上面做的所有修改都不会影响到 master 分支。本节后面会将 new_branch 分支合并到 master 分支上，合并成功之后，在 new_branch 分支上做的所有改动都会并入到 master 分支。另外，你也可以选择对一个分支进行删除操作，当一个分支被删除之后，在该分支之上的所有改动也都将被销毁，删除分支的操作不会影响到 master 分支。这便是 Git 工作流的强大之处。 合并分支操作是git merge &lt;分支名称&gt;将分支的操作合并到主分支上,注意，多人协作中当两条分支对同一个文件的同一个文本块进行了不同的修改，并试图合并时，Git不能自动合并的，称之为冲突(conflict)。解决冲突需要人工处理。，解决冲突看这里，合并分支示例： 12$ git checkout master$ git merge new_branch 从本地删除一个分支： git branch -d &lt;分支名称&gt;, 删除分支示例： 1$ git branch -d new_branch 将本地分支同步到GitHub上面： git push &lt;本地仓库名&gt; &lt;新分支名&gt; 为你的分支加入一个新的远程端： git remote add &lt;远程端名字&gt; &lt;地址&gt; 查看当前仓库有几个分支: git branch 总结经过以上配置后，之后新建仓库操作如下进行即可 进入对应目录 cd 你的仓库目录 初始化git仓库 git init 添加提交的文件 文件数 指令 一个文件 git add 文件名 全部文件 git add -A 提交修改提示 git commit -m 查看提交状态 git status 查看最近日志 git log 版本回退操作 回退次数 指令 回退一个 git reset -hard HEAD^ 回退两个 git reset -hard HEAD^^ 回退多个 git reset -hard HEAD~100 (第一次连接)远程仓库提交 git remote add origin 你复制的地址 (第二次以后)远程仓库提交 git push 参考github官方教程 Laravel 教程 - Web 开发实战入门 ( Laravel 5.5 ) Linux下Git和GitHub使用方法总结 Git 初学者 mac os x使用Git简易入门教程 《Pro Git》 推荐看下github官方教程和《Pro Git》。 结束语Git与GitHub基础教程到这就结束了，熬夜写了两晚上······半夜写头脑难免混乱可能有疏漏的地方，欢迎给我留言，有部分是参考以上链接的部分内容，侵删。希望大家看完这个教程能有一定收获，毕竟这是以后的合作途径。好了我要去补实验报告了&gt;.&lt;。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[糗事百科爬虫]]></title>
    <url>%2F2017%2F09%2F02%2Fqsbkspider%2F</url>
    <content type="text"><![CDATA[一周前买了阿里云服务器，简单部署了一个JudgeService，感觉闲着也是闲着，决定在上面部署一个爬虫，打算每隔一段时间爬取糗事百科前几页的文本段子并以邮件的形式发送到qq邮箱中。 基本环境 requests + smtplib + bs4都可以用pip install 来安装 分析需求 基本目的是爬取糗事百科文本部分前几页内容保存后续操作有通过邮件发送到邮箱，之后是挂载到云服务器上每隔一段时间自动爬取并发送邮件 分析url 我们这次只爬取文字内容，所以这次爬取的url是 ‘https://www.qiushibaike.com/text/‘点开第二页会发现 url变为 ‘https://www.qiushibaike.com/text/page/2/‘很清晰的知道 第i页的url也就是 url = ‘https://www.qiushibaike.com/text/page/%s/&#39;%str(i)我们要爬前多少页也就是一个for循环的事 分析网页源码 首先来看下网页的基本内容 我们要做的是提取这一个个文本，然后保存下来 根据网页源码很容易看出 内容是在 class=”content”的div标签下，可以直接套用正则表达式，我们这使用BeautifulSoup库的find_all函数就可以搞定 构造request请求 首先就是通过requests库得到网页源码 html = requests.get(url) 这里我们加一个小的异常处理，也就是如果爬取不到我们将错误信息写入一个文件，文件名为Http error on time.ctime() 这里的time.ctime()是包含在time里面的一个函数，返回当前时间。 然后用BeautifulSoup做成一锅汤soup = BeautifulSoup(html.text, ‘lxml’)这里我们用lxml HTML 解析器，因为它的优势是速度快，文档容错能力强，(更多关于BeautifulSoup)[http://cuiqingcai.com/1319.html] 之后我们用find_all找到每一个笑话，之后呢，把换行标签替换掉，然后加到data_list 中去 123456789101112131415161718192021222324252627282930import requestsfrom bs4 import BeautifulSoupimport timeimport lxmldef getcontent(url): try: html = requests.get(url) except: with open("log.log","a") as file: file.write("Http error on " + time.ctime()) time.sleep(60) return None soup = BeautifulSoup(html.text, 'lxml') data_list = [] for cont in soup.find_all("div", &#123;"class":"content"&#125;): raw_data = cont.get_text() data = raw_data.replace("\n","") data_list.append(data) return data_listdef main(): data_list = [] for i in range(1,2): url = 'https://www.qiushibaike.com/text/page/%s/'%str(i) temp_data = getcontent(url) data_list.extend(temp_data) for i in data_list: print(i) print('\n\n')main() 未完待续]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>linux</tag>
        <tag>requests</tag>
        <tag>BeautifulSoup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oj信息爬取]]></title>
    <url>%2F2017%2F08%2F29%2Fojrankscan%2F</url>
    <content type="text"><![CDATA[假期俱乐部举办了编程训练营，每个人负责管理15人的营，每天作业会在oj的一个总榜上关于各营营长每天统计很麻烦，所以我写了一个简单的爬虫来节省一部分工作 代码改变世界，使人更高效的完成自己的工作 基本环境 Windows 10 + python 3.6.2 + requests 库 requests 库安装1pip install requests 分析需求 首先需要统计的 Contest 有3周的作业 加 最后的结课测试 每个榜单结构都是一致的，我只需要统计自己营里的昵称和总解决数目就好 url 是 “http://oj.acmclub.cn/contestrank.php?cid=“ + contestID 右键查看网页源代码 两个a标签中刚好有我们的数据，用简单正则表达式匹配下就好 构造request爬取网页 首先拿出一个榜单来处理，由于不需要登陆就可以查看榜单所以我直接抓取榜单html页面 12345678910111213141516import requestsdef getHTMLText(url): try: r = requests.get(url, timeout=30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return ""def main(): for no in range(1166,1169): url = 'http://oj.acmclub.cn/contestrank.php?cid='+str(no) html = getHTMLText(url) print(html)main() 这算一个基本框架了，通过request得到网页源码，中间r.raise_for_status()是错误检查，后面是根据推断的编码类型设置字符编码运行结果如下 对html源码处理 首先看网页源码 这里可以用正则表达式库 re 来进行字符匹配，如果昵称符合规范xx营xx号_Nickname_name就很容易处理了，匹配两个a标签之间的内容1rege = r'&lt;a href=.*?&gt;(0&#123;0,1&#125;'+str(num)+'营.*?)&lt;/a&gt;&lt;td&gt;&lt;a href=.*?&gt;([0-9]&#123;1,2&#125;)&lt;/a&gt;' 对html的处理函数也就是很容易写了 1234567891011121314151617181920import requestsimport redef getHTMLText(url): #省略def fillscoreList(slist, html, num): rege = r'&lt;a href=.*?&gt;(0&#123;0,1&#125;'+str(num)+'营.*?)&lt;/a&gt;&lt;td&gt;&lt;a href=.*?&gt;([0-9]&#123;1,2&#125;)&lt;/a&gt;' score = re.findall(rege,html) for x in score: slist.append(x)def main(): num = int(input("请输入营号:")) for no in range(1166,1169): sinfo = [] url = 'http://oj.acmclub.cn/contestrank.php?cid='+str(no) html = getHTMLText(url) fillscoreList(sinfo, html, num) for (name,solve) in sinfo: print(name,solve)main() 这样得到的sinfo就是包含元组(name,solve)的列表，程序到这阶段基本算是完工了，但是输出的样式也并不尽人意，比如没有对齐，看起来很乱，而且三周内容挤在一块不好区分，接下来就对这个程序进行优化 格式化输出 我们想要达到的效果是三周内容清晰可辨，并且有良好的对齐，下面就来是实现下python 的 字符串 有format函数，通过这个来达到我们想要的效果对于(xx营xx号_Nickname_name,solve_num)这样一个元组，通过格式限定符来达到指定字段宽度和居中对齐 12tplt = "&#123;0:&lt;20&#125;\t\t&#123;1:^3&#125;"print(tplt.format("xx营xx号_Nickname_name"," 解决总题目数",chr(12288))) {}来指明位置 相当于c的printf中的%，{0} 指的是第0个元素，填充常跟对齐一起使用^、&lt;、&gt;分别是居中、左对齐、右对齐，后面带宽度:号后面带填充的字符，只能是一个字符，不指定的话默认是用空格填充，后面我们指定了中文空格 所以现在的程序就是这样 12345678910111213141516171819202122import requestsimport redef getHTMLText(url): #省略def fillscoreList(slist, html, num): #省略def printscoreList(slist, num): tplt = "&#123;0:20&#125;\t\t&#123;1:^3&#125;" print(tplt.format("xx营xx号_Nickname_name"," 解决题目数",chr(12288))) for i in range(num): u=slist[i] print(tplt.format(u[0],u[1],chr(12288)))def main(): num = int(input("请输入营号:")) for no in range(1166,1169): sinfo = [] url = 'http://oj.acmclub.cn/contestrank.php?cid='+str(no) html = getHTMLText(url) fillscoreList(sinfo, html, num) print("*"*15,"第%d周%d营成绩"%(int(no-1165),num),"*"*18) printscoreList(sinfo, len(sinfo))main() 运行结果如下 未完待续]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>requests</tag>
        <tag>oj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 基本语法]]></title>
    <url>%2F2017%2F08%2F25%2FMarkdown_%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[近几天刚刚搭建了博客，用的是Hexo+Next主题，托管在github和codding上，写博文是需要Markdown，所以先学习下Markdown的基本语法，也算是为博客增加一篇博文吧。 Markdown基础用法与规则： 标题使用”#”加空格在首行来创建标题如:&emsp;&emsp; # 一级标题&emsp;&emsp; ## 二级标题&emsp;&emsp; ### 三级标题 加粗功能使用一组星号”**“或一组下划线”__“来加粗一段文字，用转义符”\“来打出”*“如:&emsp;&emsp; 这是加粗的文字&emsp;&emsp; 这也是加粗的文字 引用使用”&gt;”在段首来引用一段文字，要在引用前后加入空白行声明开始和结束引用如: 这是一段引用这是一段引用 无序列表使用”-“、”*”或”+”加空格来创建无序列表如: 这是一个无序列表 这是一个无序列表 这是一个无序列表 有序列表使用数字圆点加空格如”1.”、”2.”来创建有序列表如: 这是一个有序列表 这是一个有序列表 这是一个有序列表 以上来源锤子便签 贴代码用一对重音符”``` code ```“引起来，可以在```后表明语言如: 1234567#include&lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt;"Hello World!"&lt;&lt;endl; return 0;&#125; 也可以用4个空格(Tab)缩进再贴上代码实现相同的效果 #include&lt;iostream&gt; using namespace std; int main() { cout&lt;&lt;&quot;Hello World!&quot;&lt;&lt;endl; return 0; } 强调标记用两个重音符”`强调内容`“这是一个强调标记 未完待续]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F08%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Welcome to my blog]]></title>
    <url>%2F2017%2F08%2F23%2FWelcome%2F</url>
    <content type="text"><![CDATA[123456//C#include&lt;stdio.h&gt;int main(void)&#123; printf("Hello,my friend\n"); return 0;&#125; 12345678//c++#include&lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt;"Welcome to andyhui's blog!"&lt;&lt;endl; return 0;&#125; 123456//Javapublic class Main &#123; public static void main(String[] args)&#123; System.out.println("There are some blog posts here."); &#125;&#125; 12#Pythonprint("Hope it helps you!")]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
